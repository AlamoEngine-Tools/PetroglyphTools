// Copyright (c) Alamo Engine Tools and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.IO.Abstractions;
using Moq;
using PG.Commons.Binary;
using PG.StarWarsGame.Files.MTD.Binary;
using PG.StarWarsGame.Files.MTD.Binary.Metadata;
using Testably.Abstractions.Testing;
using Xunit;

namespace PG.StarWarsGame.Files.MTD.Test.Binary.Reader;


public class MtdFileBinaryReaderTest
{
    private readonly MdtFileReader _binaryReader;

    public MtdFileBinaryReaderTest()
    {
        var fs = new MockFileSystem();
        var sp = new Mock<IServiceProvider>();
        sp.Setup(s => s.GetService(typeof(IFileSystem))).Returns(fs);
        _binaryReader = new MdtFileReader(sp.Object);
    }

    [Fact]
    public void Test__BuildMegHeader_NotSupportedFileCount()
    {
        Assert.Throws<ArgumentNullException>(() => _binaryReader.ReadBinary(null!));
    }

    [Theory]
    [MemberData(nameof(InvalidMtdData))]
    public void Test__BuildMegHeader_BinaryCorrupted(byte[] data)
    {
        var dataStream = new MemoryStream(data);
        Assert.Throws<BinaryCorruptedException>(() => _binaryReader.ReadBinary(dataStream));
    }

    public static IEnumerable<object[]> InvalidMtdData()
    {
        return
        [
            [
                Array.Empty<byte>()
            ],
            [
                // Incomplete Header
                new byte[]
                {
                    1, 0, 0
                }
            ],
            [
                // Missing entry
                new byte[]
                {
                    1, 0, 0, 0,
                }
            ],
            [
                // Incomplete name part of entry
                new byte[]
                {
                    1, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61
                }
            ],
            [
                // name is 64 chars long (missing \0 terminator)
                new byte[]
                {
                    1, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1
                }
            ],
            [
                // missing entry alpha byte
                new byte[]
                {
                    2, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0
                }
            ],
            [
                // missing entry 2
                new byte[]
                {
                    2, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1
                }
            ],
            [
                // Too high X
                new byte[]
                {
                    1, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0xFF, 0xFF, 0xFF, 0xFF,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1
                }
            ],
            [
                // Too high Y
                new byte[]
                {
                    1, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0xFF, 0xFF, 0xFF, 0xFF,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1
                }
            ],
            [
                // Too high Width
                new byte[]
                {
                    1, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0xFF, 0xFF, 0xFF, 0xFF,
                    0x1, 0x0, 0x0, 0x0,
                    0x1
                }
            ],
            [
                // Too high Height
                new byte[]
                {
                    1, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0x1, 0x0, 0x0, 0x0,
                    0xFF, 0xFF, 0xFF, 0xFF,
                    0x1
                }
            ],
        ];
    }

    [Theory]
    [MemberData(nameof(ValidMtdData))]
    public void Test__BuildMegHeader_Correct(byte[] data, IList<MtdBinaryFileInformationContainer> files)
    {
        var dataStream = new MemoryStream(data);
        var mtd = _binaryReader.ReadBinary(dataStream);

        Assert.Equal(files.Count, (int)mtd.Header.Count);
        Assert.Equal(files.Count, mtd.Items.Count);

        for (var i = 0; i < files.Count; i++)
        {
            var expected = files[i];
            var actual = mtd.Items[i];
            expected.AsserEquals(actual);
        }
    }
    public static IEnumerable<object[]> ValidMtdData()
    {
        return
        [
            [
                new byte[]
                {
                    1, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0x2, 0x0, 0x0, 0x0,
                    0x3, 0x0, 0x0, 0x0,
                    0x4, 0x0, 0x0, 0x0,
                    0x1
                },
                new List<MtdBinaryFileInformationContainer>
                {
                    new()
                    {
                        ExpectedName = new string('a', 63),
                        ExpectedAlpha = true,
                        ExpectedArea = new Rectangle(1,2,3,4)
                    }
                }
            ],
            [
                new byte[]
                {
                    2, 0, 0, 0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0x2, 0x0, 0x0, 0x0,
                    0x3, 0x0, 0x0, 0x0,
                    0x4, 0x0, 0x0, 0x0,
                    0x0,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
                    0x61, 0x61, 0x61, 0x00,
                    0x1, 0x0, 0x0, 0x0,
                    0x2, 0x0, 0x0, 0x0,
                    0x3, 0x0, 0x0, 0x0,
                    0x4, 0x0, 0x0, 0x0,
                    0xFF, // Anything but 0 is treated as true
                },
                new List<MtdBinaryFileInformationContainer>
                {
                    new()
                    {
                        ExpectedName = new string('a', 63),
                        ExpectedAlpha = false,
                        ExpectedArea = new Rectangle(1,2,3,4)
                    },
                    new()
                    {
                        ExpectedName = new string('a', 63),
                        ExpectedAlpha = true,
                        ExpectedArea = new Rectangle(1,2,3,4)
                    }
                }
            ]
        ];
    }

    public class MtdBinaryFileInformationContainer
    {
        public string ExpectedName { get; init; }

        public Rectangle ExpectedArea { get; init; }

        public bool ExpectedAlpha { get; init; }

        internal void AsserEquals(MtdBinaryFileInfo fileInfo)
        {
            Assert.Equal(ExpectedName, fileInfo.Name);
            Assert.Equal(ExpectedArea.X, (int)fileInfo.X);
            Assert.Equal(ExpectedArea.Y, (int)fileInfo.Y);
            Assert.Equal(ExpectedArea.Width, (int)fileInfo.Width);
            Assert.Equal(ExpectedArea.Height, (int)fileInfo.Height);

            Assert.Equal(ExpectedAlpha, fileInfo.Alpha);
        }
    }
}